//
//  TiltedGradientCard.swift
//  Generated by ChatGPT
//
//  Cross‑platform SwiftUI view that renders a CSS‑angle linear gradient with explicit stops
//  using Core Graphics. Angle derived from the provided image (~100.75°).
//

import SwiftUI
import CoreGraphics

#if canImport(UIKit)
import UIKit
public typealias PlatformColor = UIColor
public typealias PlatformBezierPath = UIBezierPath
#else
import AppKit
public typealias PlatformColor = NSColor
public typealias PlatformBezierPath = NSBezierPath
#endif


public struct TGStop {
    public let position: CGFloat   // 0...1
    public let color: PlatformColor
    public init(_ position: CGFloat, _ color: PlatformColor) {
        self.position = position
        self.color = color
    }
}

fileprivate func endpoints(cssAngle deg: CGFloat, in rect: CGRect) -> (CGPoint, CGPoint) {
    // CSS: 0deg = up, 90deg = right; drawing coords have y down
    let r = deg * .pi / 180
    let dx = sin(r), dy = -cos(r)
    let s = 0.5 / max(abs(dx), abs(dy)) // scale to hit rect bounds
    let cx = rect.midX, cy = rect.midY
    let p0 = CGPoint(x: cx - dx*s*rect.width,  y: cy - dy*s*rect.height)
    let p1 = CGPoint(x: cx + dx*s*rect.width,  y: cy + dy*s*rect.height)
    return (p0, p1)
}

#if canImport(UIKit)
final class TGGradientView: UIView {
    var angleCSS: CGFloat = 100.75
    var cornerRadius: CGFloat = 8
    var baseFill: PlatformColor? = nil // e.g., PlatformColor(red:1, green:0.96, blue:0.90, alpha:1)
    var overlayWhiteAlpha: CGFloat = 0.0 // e.g., 0.10 for faint wash
    var borderColor: PlatformColor = PlatformColor(white: 0.90, alpha: 1)
    var borderWidth: CGFloat = 1
    var stops: [TGStop] = []
    var colorSpace: CGColorSpace = CGColorSpace(name: CGColorSpace.extendedSRGB)!

    override class var layerClass: AnyClass { CAGradientLayer.self } // not used; we draw manually

    override func draw(_ rect: CGRect) {
        guard let ctx = UIGraphicsGetCurrentContext() else { return }
        let path = UIBezierPath(roundedRect: bounds, cornerRadius: cornerRadius).cgPath

        // 1) Base fill
        if let base = baseFill {
            ctx.setFillColor(base.cgColor)
            ctx.addPath(path); ctx.fillPath()
        }

        // 2) Main gradient
        let colors = stops.map { $0.color.cgColor } as CFArray
        let locs = stops.map { $0.position }
        if let gradient = CGGradient(colorsSpace: colorSpace, colors: colors, locations: locs) {
            ctx.saveGState()
            ctx.addPath(path); ctx.clip()
            let (p0,p1) = endpoints(cssAngle: angleCSS, in: bounds)
            ctx.drawLinearGradient(gradient, start: p0, end: p1, options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
            ctx.restoreGState()
        }

        // 3) Soft white overlay
        if overlayWhiteAlpha > 0 {
            ctx.saveGState()
            ctx.addPath(path); ctx.clip()
            ctx.setFillColor(PlatformColor(white: 1, alpha: overlayWhiteAlpha).cgColor)
            ctx.fill(bounds)
            ctx.restoreGState()
        }

        // 4) Border
        if borderWidth > 0 {
            ctx.setStrokeColor(borderColor.cgColor)
            ctx.setLineWidth(borderWidth)
            ctx.addPath(path); ctx.strokePath()
        }
    }
}
#else
final class TGGradientView: NSView {
    var angleCSS: CGFloat = 100.75
    var cornerRadius: CGFloat = 8
    var baseFill: PlatformColor? = nil
    var overlayWhiteAlpha: CGFloat = 0.0
    var borderColor: PlatformColor = PlatformColor(white: 0.90, alpha: 1)
    var borderWidth: CGFloat = 1
    var stops: [TGStop] = []
    var colorSpace: CGColorSpace = CGColorSpace(name: CGColorSpace.extendedSRGB)!

    override var isFlipped: Bool { true } // align with SwiftUI coordinates

    override func draw(_ dirtyRect: NSRect) {
        guard let ctx = NSGraphicsContext.current?.cgContext else { return }
        let path = NSBezierPath(roundedRect: bounds, xRadius: cornerRadius, yRadius: cornerRadius).cgPath

        // 1) Base fill
        if let base = baseFill {
            ctx.setFillColor(base.cgColor)
            ctx.addPath(path); ctx.fillPath()
        }

        // 2) Main gradient
        let colors = stops.map { $0.color.cgColor } as CFArray
        let locs = stops.map { $0.position }
        if let gradient = CGGradient(colorsSpace: colorSpace, colors: colors, locations: locs) {
            ctx.saveGState()
            ctx.addPath(path); ctx.clip()
            let (p0,p1) = endpoints(cssAngle: angleCSS, in: bounds)
            ctx.drawLinearGradient(gradient, start: p0, end: p1, options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
            ctx.restoreGState()
        }

        // 3) Soft white overlay
        if overlayWhiteAlpha > 0 {
            ctx.saveGState()
            ctx.addPath(path); ctx.clip()
            ctx.setFillColor(PlatformColor(white: 1, alpha: overlayWhiteAlpha).cgColor)
            ctx.fill(bounds)
            ctx.restoreGState()
        }

        // 4) Border
        if borderWidth > 0 {
            ctx.setStrokeColor(borderColor.cgColor)
            ctx.setLineWidth(borderWidth)
            ctx.addPath(path); ctx.strokePath()
        }
    }
}
#endif

public struct TiltedGradientCard: View {
    public var angleCSS: CGFloat = 100.75
    public var cornerRadius: CGFloat = 8
    public var baseFill: PlatformColor? = nil
    public var overlayWhiteAlpha: CGFloat = 0.0
    public var borderColor: PlatformColor = PlatformColor(white: 0.92, alpha: 1)
    public var borderWidth: CGFloat = 1

    // 12 sampled stops from your image (blurred bg), sRGB
    public var stops: [TGStop] = [
        TGStop(0.000, PlatformColor(srgbRed: 0.9753, green: 0.9161, blue: 0.8323, alpha: 1.0)),
        TGStop(0.091, PlatformColor(srgbRed: 0.8833, green: 0.8203, blue: 0.7559, alpha: 1.0)),
        TGStop(0.182, PlatformColor(srgbRed: 0.9259, green: 0.8294, blue: 0.7386, alpha: 1.0)),
        TGStop(0.273, PlatformColor(srgbRed: 0.9288, green: 0.8040, blue: 0.6896, alpha: 1.0)),
        TGStop(0.364, PlatformColor(srgbRed: 0.9716, green: 0.8020, blue: 0.6532, alpha: 1.0)),
        TGStop(0.455, PlatformColor(srgbRed: 0.9906, green: 0.7733, blue: 0.5878, alpha: 1.0)),
        TGStop(0.545, PlatformColor(srgbRed: 1.0000, green: 0.7344, blue: 0.5104, alpha: 1.0)),
        TGStop(0.636, PlatformColor(srgbRed: 1.0000, green: 0.6775, blue: 0.4087, alpha: 1.0)),
        TGStop(0.727, PlatformColor(srgbRed: 1.0000, green: 0.6137, blue: 0.2947, alpha: 1.0)),
        TGStop(0.818, PlatformColor(srgbRed: 1.0000, green: 0.5470, blue: 0.1745, alpha: 1.0)),
        TGStop(0.909, PlatformColor(srgbRed: 1.0000, green: 0.5220, blue: 0.1293, alpha: 1.0)),
        TGStop(1.000, PlatformColor(srgbRed: 1.0000, green: 0.6920, blue: 0.4089, alpha: 1.0))
    ]

    public init() {}

    public var body: some View {
        GradientRepresentable(angleCSS: angleCSS,
                              cornerRadius: cornerRadius,
                              baseFill: baseFill,
                              overlayWhiteAlpha: overlayWhiteAlpha,
                              borderColor: borderColor,
                              borderWidth: borderWidth,
                              stops: stops)
        // CSS-like stacked shadow approximation
        .shadow(color: Color(.sRGB, red: 1.00, green: 0.61, blue: 0.35, opacity: 0.10), radius: 40, x: 0, y: 24)
        .shadow(color: Color(.sRGB, red: 0.82, green: 0.51, blue: 0.31, opacity: 0.12), radius: 20, x: 0, y: 10)
        .shadow(color: Color(.sRGB, red: 0.82, green: 0.51, blue: 0.31, opacity: 0.10), radius: 8,  x: 0, y: 3)
    }
}

#if canImport(UIKit)
struct GradientRepresentable: UIViewRepresentable {
    var angleCSS: CGFloat; var cornerRadius: CGFloat
    var baseFill: PlatformColor?; var overlayWhiteAlpha: CGFloat
    var borderColor: PlatformColor; var borderWidth: CGFloat
    var stops: [TGStop]

    func makeUIView(context: Context) -> TGGradientView { TGGradientView() }
    func updateUIView(_ v: TGGradientView, context: Context) {
        v.angleCSS = angleCSS; v.cornerRadius = cornerRadius
        v.baseFill = baseFill; v.overlayWhiteAlpha = overlayWhiteAlpha
        v.borderColor = borderColor; v.borderWidth = borderWidth
        v.stops = stops
        v.setNeedsDisplay()
    }
}
#else
struct GradientRepresentable: NSViewRepresentable {
    var angleCSS: CGFloat; var cornerRadius: CGFloat
    var baseFill: PlatformColor?; var overlayWhiteAlpha: CGFloat
    var borderColor: PlatformColor; var borderWidth: CGFloat
    var stops: [TGStop]

    func makeNSView(context: Context) -> TGGradientView { TGGradientView() }
    func updateNSView(_ v: TGGradientView, context: Context) {
        v.angleCSS = angleCSS; v.cornerRadius = cornerRadius
        v.baseFill = baseFill; v.overlayWhiteAlpha = overlayWhiteAlpha
        v.borderColor = borderColor; v.borderWidth = borderWidth
        v.stops = stops
        v.needsDisplay = true
    }
}
#endif

// MARK: - Preview (stacked heights like your mock)
struct TiltedGradientCard_Previews: PreviewProvider {
    static var previews: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                ForEach([40, 80, 120, 160, 200], id: \.self) { h in
                    TiltedGradientCard()
                        .frame(width: 550, height: CGFloat(h))
                        .clipShape(RoundedRectangle(cornerRadius: 8, style: .continuous))
                }
            }
            .padding(24)
            .background(Color.white)
        }
        .frame(width: 640, height: 520)
    }
}
